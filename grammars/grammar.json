{
  "scopeName": "source.rho",
  "name": "rholang",
  "fileTypes": [
    "rho"
  ],
  "foldingStartMarker": "{",
  "foldingStopMarker": "}",
  "patterns": [
    { "include": "#lineComment"},
    { "include": "#blockComment"},
    { "include": "#constants"},
    { "include": "#process"},
    { "include": "#primitive"},
    { "include": "#binop"}

  ],
  "repository": {
    "lineComment": {
       "match": "//.*",
       "name": "comment.line.double-slash.rholang"
     },
    "blockComment": {
      "begin": "\/\\*.*",
      "name": "comment.block.rholang",
      "end": "\\*\/"
    },
    "process": {
      "name": "meta.process.rholang",
      "patterns": [
        { "include": "$self"},
        { "match": "\\bNil\\b",
          "name": "constant.language.rholang"
        },
        { "match": "(contract)\\s*(\\w*)\\s*\\(((?:\\w*|,|\\s)+)\\)",
          "name": "entity.function.contract.rholang",
          "captures":{
            "0": {"name": "entity.function.contract.rholang"},
            "1": {"name": "entity.keyword.rholang"},
            "2": {"name": "variable.language.channel.rholang"},
            "3": {"name": "variable.language.channel.rholang"}
          }
        },
        { "match": "(for)\\s*\\(((?:\\s|\\w|<-|;)*)\\)\\W",
          "name": "entity.function.for.rholang",
          "captures": {
            "0": {"name": "entity.function.for.rholang"},
            "1": {"name": "entity.keyword.rholang"},
            "2": {"name": "variable.language.channel.rholang"}
          }
        },
        { "match": "\\bmatch\\b",
          "name": "entity.function.match.rholang"
        },
        { "match": "\\bif\\b",
          "name": "entity.function.if.rholang"
        },
        { "match": "\\b\\*\\b",
          "name": "entity.function.star.rholang"
        },
        { "match": "(new)\\s*((?:\\w*|,|\\s*)+)\\s*in\\W",
          "name": "storage.type.namespace.rholang",
          "captures": {
            "0": {"name": "storage.type.namespace.rholang"},
            "1": {"name": "entity.keyword.rholang"},
            "2": {"name": "variable.language.channel.rholang"}
          }

        }
      ]
    },
    "primitive": {
      "patterns": [
        { "match": "\\b(true|false)\\b",
          "name": "constant.language.bool.rholang"
        },
        { "match": "\\W\\d+\\W",
          "name": "constant.numeric.rholang"
        },
        { "begin": "\"",
          "end": "\"",
          "name": "string.quoted.double.rholang"
        },
        { "begin": "'",
          "end": "'",
          "name": "string.quoted.single.rholang"
        },
        { "begin": "\\bDateTime\\s*\\(",
          "end": "\\)",
          "name": "constant.other.datatime"
        },
        { "begin": "`",
          "end": "`",
          "name": "constant.language.uri.rholang"
        }
      ]

    },
    "binop": {
      "patterns": [
        { "match": "\\=\\=",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "!=",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "\\b(and|or)\\b",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "\\+",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "(\\*|\\%)",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "(\\-|\\/)",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "(\\<\\=|\\<|\\>\\=|\\>)",
          "name": "keyword.operator.binop.rholang"
        },
        { "match": "\\b(bitand|bitor)\\b",
          "name": "keyword.operator.binop.rholang"
        }
      ]
    },
    "unop": {
      "patterns": [
        { "match": "\\b(?:not|bitnot|\\+|\\-)\\b",
          "name": "keyword.operator.unop.rholang"
        }
      ]
    }




  }
}
